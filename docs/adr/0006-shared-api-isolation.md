# 0007. Модуль `feature:shared-api` и изоляция фичей

Дата: 13.10.2025

## Статус

Принято

## Контекст

При разработке фичей возникает соблазн переиспользовать модели между фичами для избежания дублирования кода. Однако это
создаёт скрытые зависимости и нарушает принцип изоляции фичей. Необходимо определить чёткие правила использования общих
моделей и принципы изоляции.

## Решение

Устанавливаем принцип **максимальной изоляции фичей** с минимальным использованием общих моделей.

### Основное правило

**В большинстве случаев дублируем модели в каждой фиче**, чтобы фичи были максимально независимы.

Общие модели выносятся в `:feature:shared-api` только в **очень редких случаях**, когда это действительно обосновано.

### Принципы изоляции фичей

**Явная конвертация на стыках:**

- Заставляем клиентский код конвертировать одни сущности в другие на стыке фичей
- Это обеспечивает полную изоляцию и независимость фичей
- Предотвращает скрытые связи через общие модели

**Преимущества изоляции:**

- Фичи могут эволюционировать независимо
- Изменения в одной фиче не влияют на другие
- Чёткие границы ответственности
- Упрощение тестирования и отладки

### Когда использовать shared-api

Модель может быть вынесена в `:feature:shared-api` только при соблюдении **всех** условий:

1. **Массовость:** Модель используется как минимум тремя фичами проекта
2. **Стабильность:** Модель крайне редко изменяется
3. **Фундаментальность:** Модель представляет базовую сущность домена (например, `UserId`, `Money`, `DateTime`)
4. **Единообразие:** Изменение модели должно затронуть весь проект единообразно

**Примеры подходящих моделей:**

- `UserId` — идентификатор пользователя
- `Money` — денежная сумма с валютой
- `DateTime` — временные метки
- `AppVersion` — версия приложения

**Примеры НЕподходящих моделей:**

- `User` — слишком сложная, может различаться между фичами
- `Order` — специфична для определённых фичей
- `PaymentMethod` — может эволюционировать независимо

### Структура shared-api

```
:feature:shared-api/
└── entity/
    ├── UserId.kt                         # <package>.feature.shared.entity
    ├── Money.kt                          # <package>.feature.shared.entity
    ├── DateTime.kt                       # <package>.feature.shared.entity
    └── AppVersion.kt                     # <package>.feature.shared.entity
```

**Правила организации:**

- Модели находятся только в пакете `entity`
- Никаких интерфейсов или бизнес-логики в модуле
- Простые data/enum class'ы без сложной логики

### Пример изоляции через конвертацию

```kotlin
// :feature:orders:api
data class OrderUser(val id: String, val name: String, val email: String)

// :feature:payments:api
data class PaymentUser(val userId: String, val displayName: String)

// :feature:notifications:api
data class NotificationRecipient(val userId: String, val contactEmail: String)

// В клиентском коде явная конвертация
class OrdersFeatureImpl(
    private val paymentsFeature: PaymentsFeature,
    private val notificationsFeature: NotificationsFeature
) : OrdersFeature {

    override suspend fun processOrder(order: Order) {
        // Явная конвертация для payments
        val paymentUser = PaymentUser(
            userId = order.user.id,
            displayName = order.user.name
        )

        // Явная конвертация для notifications
        val recipient = NotificationRecipient(
            userId = order.user.id,
            contactEmail = order.user.email
        )

        paymentsFeature.processPayment(paymentUser, order.amount)
        notificationsFeature.sendOrderConfirmation(recipient, order.id)
    }
}
```

### Альтернативы shared-api

**Вместо shared-api более предпочтительны:**

1. **Дублирование моделей** в каждой фиче
2. **Конвертация на границах** фичей
3. **Локальные модели** специфичные для каждой фичи

**Пример правильного дублирования:**

```kotlin
// :feature:orders:api
data class OrderMoney(val amount: BigDecimal, val currency: String)

// :feature:payments:api
data class PaymentAmount(val value: BigDecimal, val currencyCode: String)

// Конвертация при необходимости (близко к вызову PaymentFeature)
fun OrderMoney.toPaymentAmount() = PaymentAmount(
    value = amount,
    currencyCode = currency
)
```

### Вопрос-ответ

**Почему не переиспользовать модели напрямую?**  
Это создаёт скрытые зависимости и нарушает изоляцию фичей.

**Не приводит ли дублирование к проблемам синхронизации?**  
Нет, если фичи правильно изолированы. Каждая фича развивается по своим потребностям.

**Когда точно НЕ использовать shared-api?**  
Когда модель может изменяться независимо в разных фичах или используется не всеми фичами.

**Как быть с большими моделями?**  
Разбивать на более мелкие или дублировать только нужные поля в каждой фиче.

## Последствия

**Положительные:**

- Максимальная независимость и изоляция фичей
- Возможность независимой эволюции моделей в каждой фиче
- Отсутствие скрытых зависимостей через общие модели
- Чёткие границы ответственности
- Упрощение рефакторинга отдельных фичей

**Отрицательные:**

- Дублирование кода моделей между фичами
- Необходимость явной конвертации на стыках фичей
- Потенциальное увеличение объёма кода
- Требуется дисциплина при соблюдении принципов изоляции
