# 0005. Внутренняя структура `impl`-модулей (пакеты `di`, `domain`, `data`)

Дата: 13.10.2025

## Статус

Принято

## Контекст

Необходима единая структура реализации фичи, обеспечивающая чистую архитектуру и удобную навигацию.

## Решение

Каждый `impl`-модуль организуется в соответствии с mini-Clean Architecture:

```
feature/
└── <name>/
    └── impl/                          # Impl-модуль :feature:<name>:impl
        ├── domain/                    # бизнес-логика, интеракторы, интерфейсы репозиториев
        ├── data/                      # реализации репозиториев, network, db, dto, mappers
        ├── di/                        # DI-модули, биндинги api → impl и внутренних зависимостей
        └── XxxFeatureImpl.kt          # адаптер от публичного контракта к внутренней логике
```

**Именование пакетов:**

- `domain/`: `one.premier.feature.<feature.name>.impl.domain`
- `data/`: `one.premier.feature.<feature.name>.impl.data`
- `di/`: `one.premier.feature.<feature.name>.impl.di`
- `XxxFeatureImpl.kt`: `one.premier.feature.<feature.name>.impl`

*Подробнее см. ADR [0007](0007-feature-naming-conventions.md) - Конвенции именования feature-модулей*

**Важно!!!** Все внутри impl помечаются `internal`, кроме DI-модуля, который импортируется в `app`.

**Критически важно:** Слои `data/` и `ui/` являются неотъемлемой частью impl-модуля и **не выносятся** в отдельные модули. Вся реализация фичи должна находиться в рамках одного impl-модуля.

*Подробнее о типах фич и их специализированной структуре см. ADR [0009](0009-feature-types.md) - Типы feature-модулей (Domain vs UI)*

### Вопрос-ответ

**Где хранится бизнес-логика (domain-слой реализации фичи)?**  
В `domain/` (интеракторы, интерфейсы репозиториев).

**Где хранится слой данных?**  
В `data/` (реализация репозиориев, сетевой слой, доступ к DB и т.д.). **Важно:** Слой данных является частью impl-модуля и не выносится в отдельный модуль.

**Где хранится ui-слой?**  
В `ui/` (реализация View, ViewState, ViewModel и т.д.). **Важно:** UI-слой является частью impl-модуля и не выносится в отдельный модуль.

**Что делает `XxxFeatureImpl`?**  
Тонкий адаптер: реализует контракт, делегирует в `domain`.

**Можно ли зависеть от других фичей?**  
Да, но только через их `*:api`.

**Где DI?**  
В `di/`, где объявляются биндинги; связывание активируется в `app`. DI-модуль должен быть публичным (не `internal`), так
как он импортируется в `app`-модуле.

**Что должно быть `internal`?**  
Всё содержимое `impl`-модуля, кроме DI-модуля: `domain/`, `data/`, `XxxFeatureImpl` и все их внутренние классы.

**Как тестировать?**

- Мокать `XxxFeature` для интеграционных тестов
- Тестировать `domain` и `data` изолированно

### Пример

```kotlin
// api
interface PaymentsFeature {
    suspend fun process(request: PaymentRequest): PaymentResult
}

// impl
internal class PaymentsFeatureImpl(
    private val interactor: PaymentInteractor
) : PaymentsFeature {
    override suspend fun process(request: PaymentRequest) =
        interactor.process(request)
}
```

### Последствия

**Положительные:**

- Единообразие и чистая изоляция фич
- Простая замена реализации
- Предсказуемая структура проекта

**Отрицательные:**

- Больше слоёв и файлов
- Требуется контроль internal-границ
